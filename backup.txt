#![feature(int_abs_diff)]
#![allow(non_snake_case)]

use std::collections::HashMap;
use std::env;
use std::fs::File;
use std::io::{BufRead, BufReader, BufWriter, Write};
use std::time::SystemTime;

const MAX_GEWICHT: i64 = 10000;
const MIN_GEWICHT: i64 = 0;

static mut MAX: i64 = i64::MAX;
static mut MIN: i64 = i64::MIN;

fn main() {
    let args: Vec<String> = env::args().collect();
    let input_file = args
        .get(1)
        .expect("Please provide the path to an input file");
    let output_file = args
        .get(2)
        .expect("Please provide the path of the output file");

    solve(input_file, output_file);
}

fn solve(input_file_path: &str, output_file_path: &str) {
    let file = File::open(input_file_path).expect("Failed to read file");

    println!(
        "\n========================================\n+ Solving for {}",
        input_file_path
    );

    let arr = read_weights(&file);

    let mut sums: HashMap<i64, Vec<i64>> = HashMap::new();
    let mut counters = vec![0; arr.len()];
    let start = SystemTime::now();
    recurse(&mut sums, &arr, 0, &mut counters);

    println!(
        "+ Successfully ran algorithm.\n\t> Finished in {:?}\n\t> Total sums: {}",
        start.elapsed().unwrap_or_default(),
        sums.len()
    );

    unsafe {
        MAX = i64::MAX;
        MIN = i64::MIN;
    }

    let start = SystemTime::now();
    write_solution(&sums, &arr, output_file_path);
    println!(
        "+ Writing solution to file.\n\t> Finished in {:?}",
        start.elapsed().unwrap_or_default()
    )
}

fn recurse(
    sums: &mut HashMap<i64, Vec<i64>>,
    arr: &Vec<Vec<i64>>,
    n: usize,
    counters: &mut Vec<i64>,
) {
    if n == arr.len() {
        //Summe aufzählen
        let mut sum: i64 = 0;
        for i in 0..arr.len() {
            let ints = arr.get(i).unwrap();
            sum += ints[counters[i] as usize];
        }

        //Nur einfügen, wenn das maximale Gewicht und das minimale Gewicht eingehalten werden
        unsafe {
            if sum <= MAX_GEWICHT && sum >= MIN_GEWICHT {
                sums.insert(sum, counters.clone());
            } else if sum > MIN && sum < MIN_GEWICHT {
                sums.remove(&MIN);
                MIN = sum;
                sums.insert(sum, counters.clone());
            } else if sum < MAX && sum > MAX_GEWICHT {
                sums.remove(&MAX);
                MAX = sum;
                sums.insert(sum, counters.clone());
            }
        }
        return;
    }

    for i in 0..arr.get(n).expect("No arr at index n").len() {
        counters[n] = i as i64;
        recurse(sums, arr, n + 1, counters);
    }
}

fn read_weights(file: &File) -> Vec<Vec<i64>> {
    let start = SystemTime::now();
    let reader = BufReader::new(file);

    let mut permutations = 1;

    let mut arr: Vec<Vec<i64>> = vec![];

    for line in reader.lines().skip(1) {
        let line = line.unwrap();

        let weight: i64 = line
            .split(" ")
            .nth(0)
            .expect("Failed to read weight")
            .parse()
            .expect("Failed to parse weight");

        let count: i64 = line
            .split(" ")
            .nth(1)
            .expect("Failed to read weight-count")
            .parse()
            .expect("Failed to parse weight-count");

        permutations *= 2 * count + 1;

        arr.push(generate_weight_perms(count, weight))
    }

    println!(
        "+ Successfully generated weights from file.\n\t> Finished in {:?}\n\t> Estimated sums: {}",
        start.elapsed().unwrap_or_default(),
        permutations
    );

    return arr;
}

fn generate_weight_perms(count: i64, weight: i64) -> Vec<i64> {
    let mut weights = Vec::new();
    for i in (-count)..(count + 1) {
        weights.push(i * weight);
    }
    return weights;
}

fn fill_with_rounded(arr: &mut Vec<(i64, Vec<i64>, Vec<i64>)>){
    arr.remove(0);
    let mut last_og = 0;

    let max = arr[arr.len()-1].0;

    for i in MIN_GEWICHT as usize..i64::min(max,MAX_GEWICHT) as usize {
        if arr[i].0 != i as i64 {
            if i.abs_diff(last_og) > i.abs_diff(arr[i].0 as usize) {
                arr.insert(i, (i as i64, arr[i].1.clone(), arr[i].2.clone()));
            }else {
                arr.insert(i, (last_og as i64+1, arr[i].1.clone(), arr[i].2.clone()));
            }
        }else {
            last_og = i;
        }
    }

    for i in i64::min(max, MAX_GEWICHT) as usize..MAX_GEWICHT as usize{
        arr.push((i as i64, arr[i].1.clone(), arr[i].2.clone()));
    }
}

fn write_solution(sums: &HashMap<i64, Vec<i64>>, arr: &Vec<Vec<i64>>, file_name: &str) {
    let weights = {
        let mut vec = vec![];
        for local in arr {
            vec.push(local[local.len() - 1] / ((local.len() - 1) >> 1) as i64)
        }
        vec
    };

    let mut sorted: Vec<_> = sums.iter().collect();
    sorted.sort();

    let path = std::path::Path::new(file_name);
    if let Some(parent_path) = path.parent() {
        std::fs::create_dir_all(parent_path).unwrap();
    }

    let output = File::create(file_name).expect("Failed to create output-file");

    let mut writer = BufWriter::new(output);

    let mut output = vec![];

    for entry in sorted {
        let sum = entry.0;
        let counters = entry.1;

        let mut left = vec![];
        let mut right = vec![];

        for i in 0..weights.len() {
            let weight = weights[i];
            let multiple = arr[i][counters[i] as usize];
            let abs_count = (multiple / weight).abs();

            if multiple.is_negative() {
                for _ in 0..abs_count {
                    left.push(weight)
                }
            } else if multiple.is_positive() {
                for _ in 0..abs_count {
                    right.push(weight)
                }
            }
        }

        output.push((*sum, left, right));
    }
    //fill_with_rounded(&mut output);

    for entry in output {
        let sum = entry.0;
        let left = entry.1;
        let right = entry.2;
        writer
            .write(
                format!(
                    "weight={}\t\tleft: {:?}\n\t\t\t\tright: {:?}\n",
                    sum, left, right
                )
                    .as_bytes(),
            )
            .expect("Failed to write to output-file");
    }
}
